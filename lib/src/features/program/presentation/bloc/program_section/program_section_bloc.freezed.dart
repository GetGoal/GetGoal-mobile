// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'program_section_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ProgramSectionEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() onSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? onSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? onSearch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionEventStarted value) started,
    required TResult Function(ProgramSectionEventOnSearch value) onSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionEventStarted value)? started,
    TResult? Function(ProgramSectionEventOnSearch value)? onSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionEventStarted value)? started,
    TResult Function(ProgramSectionEventOnSearch value)? onSearch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProgramSectionEventCopyWith<$Res> {
  factory $ProgramSectionEventCopyWith(
          ProgramSectionEvent value, $Res Function(ProgramSectionEvent) then) =
      _$ProgramSectionEventCopyWithImpl<$Res, ProgramSectionEvent>;
}

/// @nodoc
class _$ProgramSectionEventCopyWithImpl<$Res, $Val extends ProgramSectionEvent>
    implements $ProgramSectionEventCopyWith<$Res> {
  _$ProgramSectionEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ProgramSectionEventStartedImplCopyWith<$Res> {
  factory _$$ProgramSectionEventStartedImplCopyWith(
          _$ProgramSectionEventStartedImpl value,
          $Res Function(_$ProgramSectionEventStartedImpl) then) =
      __$$ProgramSectionEventStartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramSectionEventStartedImplCopyWithImpl<$Res>
    extends _$ProgramSectionEventCopyWithImpl<$Res,
        _$ProgramSectionEventStartedImpl>
    implements _$$ProgramSectionEventStartedImplCopyWith<$Res> {
  __$$ProgramSectionEventStartedImplCopyWithImpl(
      _$ProgramSectionEventStartedImpl _value,
      $Res Function(_$ProgramSectionEventStartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramSectionEventStartedImpl implements ProgramSectionEventStarted {
  const _$ProgramSectionEventStartedImpl();

  @override
  String toString() {
    return 'ProgramSectionEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProgramSectionEventStartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() onSearch,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? onSearch,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? onSearch,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionEventStarted value) started,
    required TResult Function(ProgramSectionEventOnSearch value) onSearch,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionEventStarted value)? started,
    TResult? Function(ProgramSectionEventOnSearch value)? onSearch,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionEventStarted value)? started,
    TResult Function(ProgramSectionEventOnSearch value)? onSearch,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class ProgramSectionEventStarted implements ProgramSectionEvent {
  const factory ProgramSectionEventStarted() = _$ProgramSectionEventStartedImpl;
}

/// @nodoc
abstract class _$$ProgramSectionEventOnSearchImplCopyWith<$Res> {
  factory _$$ProgramSectionEventOnSearchImplCopyWith(
          _$ProgramSectionEventOnSearchImpl value,
          $Res Function(_$ProgramSectionEventOnSearchImpl) then) =
      __$$ProgramSectionEventOnSearchImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramSectionEventOnSearchImplCopyWithImpl<$Res>
    extends _$ProgramSectionEventCopyWithImpl<$Res,
        _$ProgramSectionEventOnSearchImpl>
    implements _$$ProgramSectionEventOnSearchImplCopyWith<$Res> {
  __$$ProgramSectionEventOnSearchImplCopyWithImpl(
      _$ProgramSectionEventOnSearchImpl _value,
      $Res Function(_$ProgramSectionEventOnSearchImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramSectionEventOnSearchImpl implements ProgramSectionEventOnSearch {
  const _$ProgramSectionEventOnSearchImpl();

  @override
  String toString() {
    return 'ProgramSectionEvent.onSearch()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProgramSectionEventOnSearchImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() onSearch,
  }) {
    return onSearch();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? onSearch,
  }) {
    return onSearch?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? onSearch,
    required TResult orElse(),
  }) {
    if (onSearch != null) {
      return onSearch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionEventStarted value) started,
    required TResult Function(ProgramSectionEventOnSearch value) onSearch,
  }) {
    return onSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionEventStarted value)? started,
    TResult? Function(ProgramSectionEventOnSearch value)? onSearch,
  }) {
    return onSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionEventStarted value)? started,
    TResult Function(ProgramSectionEventOnSearch value)? onSearch,
    required TResult orElse(),
  }) {
    if (onSearch != null) {
      return onSearch(this);
    }
    return orElse();
  }
}

abstract class ProgramSectionEventOnSearch implements ProgramSectionEvent {
  const factory ProgramSectionEventOnSearch() =
      _$ProgramSectionEventOnSearchImpl;
}

/// @nodoc
mixin _$ProgramSectionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() hide,
    required TResult Function() failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function()? hide,
    TResult? Function()? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? hide,
    TResult Function()? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionStateInitial value) initial,
    required TResult Function(ProgramSectionStateLoading value) loading,
    required TResult Function(ProgramSectionStateSuccess value) success,
    required TResult Function(ProgramSectionStateHide value) hide,
    required TResult Function(ProgramSectionStateFailure value) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionStateInitial value)? initial,
    TResult? Function(ProgramSectionStateLoading value)? loading,
    TResult? Function(ProgramSectionStateSuccess value)? success,
    TResult? Function(ProgramSectionStateHide value)? hide,
    TResult? Function(ProgramSectionStateFailure value)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionStateInitial value)? initial,
    TResult Function(ProgramSectionStateLoading value)? loading,
    TResult Function(ProgramSectionStateSuccess value)? success,
    TResult Function(ProgramSectionStateHide value)? hide,
    TResult Function(ProgramSectionStateFailure value)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProgramSectionStateCopyWith<$Res> {
  factory $ProgramSectionStateCopyWith(
          ProgramSectionState value, $Res Function(ProgramSectionState) then) =
      _$ProgramSectionStateCopyWithImpl<$Res, ProgramSectionState>;
}

/// @nodoc
class _$ProgramSectionStateCopyWithImpl<$Res, $Val extends ProgramSectionState>
    implements $ProgramSectionStateCopyWith<$Res> {
  _$ProgramSectionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ProgramSectionStateInitialImplCopyWith<$Res> {
  factory _$$ProgramSectionStateInitialImplCopyWith(
          _$ProgramSectionStateInitialImpl value,
          $Res Function(_$ProgramSectionStateInitialImpl) then) =
      __$$ProgramSectionStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramSectionStateInitialImplCopyWithImpl<$Res>
    extends _$ProgramSectionStateCopyWithImpl<$Res,
        _$ProgramSectionStateInitialImpl>
    implements _$$ProgramSectionStateInitialImplCopyWith<$Res> {
  __$$ProgramSectionStateInitialImplCopyWithImpl(
      _$ProgramSectionStateInitialImpl _value,
      $Res Function(_$ProgramSectionStateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramSectionStateInitialImpl implements ProgramSectionStateInitial {
  const _$ProgramSectionStateInitialImpl();

  @override
  String toString() {
    return 'ProgramSectionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProgramSectionStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() hide,
    required TResult Function() failure,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function()? hide,
    TResult? Function()? failure,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? hide,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionStateInitial value) initial,
    required TResult Function(ProgramSectionStateLoading value) loading,
    required TResult Function(ProgramSectionStateSuccess value) success,
    required TResult Function(ProgramSectionStateHide value) hide,
    required TResult Function(ProgramSectionStateFailure value) failure,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionStateInitial value)? initial,
    TResult? Function(ProgramSectionStateLoading value)? loading,
    TResult? Function(ProgramSectionStateSuccess value)? success,
    TResult? Function(ProgramSectionStateHide value)? hide,
    TResult? Function(ProgramSectionStateFailure value)? failure,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionStateInitial value)? initial,
    TResult Function(ProgramSectionStateLoading value)? loading,
    TResult Function(ProgramSectionStateSuccess value)? success,
    TResult Function(ProgramSectionStateHide value)? hide,
    TResult Function(ProgramSectionStateFailure value)? failure,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ProgramSectionStateInitial implements ProgramSectionState {
  const factory ProgramSectionStateInitial() = _$ProgramSectionStateInitialImpl;
}

/// @nodoc
abstract class _$$ProgramSectionStateLoadingImplCopyWith<$Res> {
  factory _$$ProgramSectionStateLoadingImplCopyWith(
          _$ProgramSectionStateLoadingImpl value,
          $Res Function(_$ProgramSectionStateLoadingImpl) then) =
      __$$ProgramSectionStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramSectionStateLoadingImplCopyWithImpl<$Res>
    extends _$ProgramSectionStateCopyWithImpl<$Res,
        _$ProgramSectionStateLoadingImpl>
    implements _$$ProgramSectionStateLoadingImplCopyWith<$Res> {
  __$$ProgramSectionStateLoadingImplCopyWithImpl(
      _$ProgramSectionStateLoadingImpl _value,
      $Res Function(_$ProgramSectionStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramSectionStateLoadingImpl implements ProgramSectionStateLoading {
  const _$ProgramSectionStateLoadingImpl();

  @override
  String toString() {
    return 'ProgramSectionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProgramSectionStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() hide,
    required TResult Function() failure,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function()? hide,
    TResult? Function()? failure,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? hide,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionStateInitial value) initial,
    required TResult Function(ProgramSectionStateLoading value) loading,
    required TResult Function(ProgramSectionStateSuccess value) success,
    required TResult Function(ProgramSectionStateHide value) hide,
    required TResult Function(ProgramSectionStateFailure value) failure,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionStateInitial value)? initial,
    TResult? Function(ProgramSectionStateLoading value)? loading,
    TResult? Function(ProgramSectionStateSuccess value)? success,
    TResult? Function(ProgramSectionStateHide value)? hide,
    TResult? Function(ProgramSectionStateFailure value)? failure,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionStateInitial value)? initial,
    TResult Function(ProgramSectionStateLoading value)? loading,
    TResult Function(ProgramSectionStateSuccess value)? success,
    TResult Function(ProgramSectionStateHide value)? hide,
    TResult Function(ProgramSectionStateFailure value)? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ProgramSectionStateLoading implements ProgramSectionState {
  const factory ProgramSectionStateLoading() = _$ProgramSectionStateLoadingImpl;
}

/// @nodoc
abstract class _$$ProgramSectionStateSuccessImplCopyWith<$Res> {
  factory _$$ProgramSectionStateSuccessImplCopyWith(
          _$ProgramSectionStateSuccessImpl value,
          $Res Function(_$ProgramSectionStateSuccessImpl) then) =
      __$$ProgramSectionStateSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramSectionStateSuccessImplCopyWithImpl<$Res>
    extends _$ProgramSectionStateCopyWithImpl<$Res,
        _$ProgramSectionStateSuccessImpl>
    implements _$$ProgramSectionStateSuccessImplCopyWith<$Res> {
  __$$ProgramSectionStateSuccessImplCopyWithImpl(
      _$ProgramSectionStateSuccessImpl _value,
      $Res Function(_$ProgramSectionStateSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramSectionStateSuccessImpl implements ProgramSectionStateSuccess {
  const _$ProgramSectionStateSuccessImpl();

  @override
  String toString() {
    return 'ProgramSectionState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProgramSectionStateSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() hide,
    required TResult Function() failure,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function()? hide,
    TResult? Function()? failure,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? hide,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionStateInitial value) initial,
    required TResult Function(ProgramSectionStateLoading value) loading,
    required TResult Function(ProgramSectionStateSuccess value) success,
    required TResult Function(ProgramSectionStateHide value) hide,
    required TResult Function(ProgramSectionStateFailure value) failure,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionStateInitial value)? initial,
    TResult? Function(ProgramSectionStateLoading value)? loading,
    TResult? Function(ProgramSectionStateSuccess value)? success,
    TResult? Function(ProgramSectionStateHide value)? hide,
    TResult? Function(ProgramSectionStateFailure value)? failure,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionStateInitial value)? initial,
    TResult Function(ProgramSectionStateLoading value)? loading,
    TResult Function(ProgramSectionStateSuccess value)? success,
    TResult Function(ProgramSectionStateHide value)? hide,
    TResult Function(ProgramSectionStateFailure value)? failure,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class ProgramSectionStateSuccess implements ProgramSectionState {
  const factory ProgramSectionStateSuccess() = _$ProgramSectionStateSuccessImpl;
}

/// @nodoc
abstract class _$$ProgramSectionStateHideImplCopyWith<$Res> {
  factory _$$ProgramSectionStateHideImplCopyWith(
          _$ProgramSectionStateHideImpl value,
          $Res Function(_$ProgramSectionStateHideImpl) then) =
      __$$ProgramSectionStateHideImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramSectionStateHideImplCopyWithImpl<$Res>
    extends _$ProgramSectionStateCopyWithImpl<$Res,
        _$ProgramSectionStateHideImpl>
    implements _$$ProgramSectionStateHideImplCopyWith<$Res> {
  __$$ProgramSectionStateHideImplCopyWithImpl(
      _$ProgramSectionStateHideImpl _value,
      $Res Function(_$ProgramSectionStateHideImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramSectionStateHideImpl implements ProgramSectionStateHide {
  const _$ProgramSectionStateHideImpl();

  @override
  String toString() {
    return 'ProgramSectionState.hide()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProgramSectionStateHideImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() hide,
    required TResult Function() failure,
  }) {
    return hide();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function()? hide,
    TResult? Function()? failure,
  }) {
    return hide?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? hide,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (hide != null) {
      return hide();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionStateInitial value) initial,
    required TResult Function(ProgramSectionStateLoading value) loading,
    required TResult Function(ProgramSectionStateSuccess value) success,
    required TResult Function(ProgramSectionStateHide value) hide,
    required TResult Function(ProgramSectionStateFailure value) failure,
  }) {
    return hide(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionStateInitial value)? initial,
    TResult? Function(ProgramSectionStateLoading value)? loading,
    TResult? Function(ProgramSectionStateSuccess value)? success,
    TResult? Function(ProgramSectionStateHide value)? hide,
    TResult? Function(ProgramSectionStateFailure value)? failure,
  }) {
    return hide?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionStateInitial value)? initial,
    TResult Function(ProgramSectionStateLoading value)? loading,
    TResult Function(ProgramSectionStateSuccess value)? success,
    TResult Function(ProgramSectionStateHide value)? hide,
    TResult Function(ProgramSectionStateFailure value)? failure,
    required TResult orElse(),
  }) {
    if (hide != null) {
      return hide(this);
    }
    return orElse();
  }
}

abstract class ProgramSectionStateHide implements ProgramSectionState {
  const factory ProgramSectionStateHide() = _$ProgramSectionStateHideImpl;
}

/// @nodoc
abstract class _$$ProgramSectionStateFailureImplCopyWith<$Res> {
  factory _$$ProgramSectionStateFailureImplCopyWith(
          _$ProgramSectionStateFailureImpl value,
          $Res Function(_$ProgramSectionStateFailureImpl) then) =
      __$$ProgramSectionStateFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProgramSectionStateFailureImplCopyWithImpl<$Res>
    extends _$ProgramSectionStateCopyWithImpl<$Res,
        _$ProgramSectionStateFailureImpl>
    implements _$$ProgramSectionStateFailureImplCopyWith<$Res> {
  __$$ProgramSectionStateFailureImplCopyWithImpl(
      _$ProgramSectionStateFailureImpl _value,
      $Res Function(_$ProgramSectionStateFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ProgramSectionStateFailureImpl implements ProgramSectionStateFailure {
  const _$ProgramSectionStateFailureImpl();

  @override
  String toString() {
    return 'ProgramSectionState.failure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProgramSectionStateFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() hide,
    required TResult Function() failure,
  }) {
    return failure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? success,
    TResult? Function()? hide,
    TResult? Function()? failure,
  }) {
    return failure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? hide,
    TResult Function()? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ProgramSectionStateInitial value) initial,
    required TResult Function(ProgramSectionStateLoading value) loading,
    required TResult Function(ProgramSectionStateSuccess value) success,
    required TResult Function(ProgramSectionStateHide value) hide,
    required TResult Function(ProgramSectionStateFailure value) failure,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ProgramSectionStateInitial value)? initial,
    TResult? Function(ProgramSectionStateLoading value)? loading,
    TResult? Function(ProgramSectionStateSuccess value)? success,
    TResult? Function(ProgramSectionStateHide value)? hide,
    TResult? Function(ProgramSectionStateFailure value)? failure,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ProgramSectionStateInitial value)? initial,
    TResult Function(ProgramSectionStateLoading value)? loading,
    TResult Function(ProgramSectionStateSuccess value)? success,
    TResult Function(ProgramSectionStateHide value)? hide,
    TResult Function(ProgramSectionStateFailure value)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class ProgramSectionStateFailure implements ProgramSectionState {
  const factory ProgramSectionStateFailure() = _$ProgramSectionStateFailureImpl;
}
